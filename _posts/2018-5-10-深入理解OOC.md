---
layout: post
title: 深入理解 OOC
date: 2018-5-10
categories: C/C++
tags: [OOC, C/C++]
grammar_cjkRuby: true
---

# 1 简介
## 1.1 什么是 OOC?
OOC（Object Oriented C) 是一个高效、轻量的面向对象的 ANSI-C 扩展，用于支持ANSI-C面向对象的软件开发。它支持
* 封装：隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读取和修改的访问级别。
* 单继承，多接口继：根据现有类定义新类和行为的能力。
* 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。。

## 1.2 为何要用 OOC？
“Program to interfaces, not to implementations”  已经成为面向对象的编程的共识，它可以有效的减小系统之间的依赖，提高软件的开发质量。然而目前依然有很多嵌入式的平台缺乏面向对象语言的工具链，ANSI-C 依然是很对嵌入式平台的主流开发语言，因此，如果能在c语言中找到一种模拟继承和多态性的方法，就可在这种非面向对象的语言中实现 OO 的设计模式。

# 2 如何实现 OOC?
简而言之，OOC使用宏来描述和使用类。下面深入讲解 OOC 的具体实现。
## 2.1 封装
在本节中，我将解释OOC框架如何实现封装。我将介绍一个简单类的创建过程，它的**数据隐藏是通过命名约定执行的**。

假设我们想要写一个程序来打印某个公司员工的信息。很明显，我们需要定义一个类来收集员工的所有信息。

``` stylus
// employee.h
#ifndef __EMPLOYEE_H__
#define __EMPLOYEE_H__

struct Employee
{
    const char *szName;
    float salary;
};

void PrintEmployee(struct Employee *pEm);
#endif
```
它的简单实现如下：
``` stylus
// employee.c
#include <stdio.h>
#include "employee.h"

void PrintEmployee(struct Employee *pEm)
{
    printf("Name: %s, Salary: %f", pEm->szName, pEm->salary);
}

```
很显然，上面的实现由几个缺点：
* 缺乏构造和析构函数，需要使用者自己初始化和清理结构体里的成员，从而导致代码中可能会有多处构造和析构的代码，增加维护的难度。
* 一个好的C开发人员会添加函数来初始化结构体并在结束的时候清理它，但这仍然不能保证用户一定会调用它。

因此，封装是我们所需要的。通过使用统一的编码规则和命名约定，我们可以再在C 中模拟类的实现。
 - 类属性都是结构中的成员。
 - 类方法时 C 函数， 它第一个参数是指向该属性结构的指针，称它为self。
 - 为了进一步加强属性、类方法和类之间的关系，我们应用了一致的命名规则。类方法是类名与操作名称的连接，用下划线分隔，例如Employee_Print。这个简单的命名约定还可以防止不同类方法之间的命名冲突。
 - 访问控制是使用命名约定处理的另一方面。大多数OO语言提供了以下级别的保护:
	* private: 只能从类中访问，变量名以两个下划线"\_\_"开始。
	* protected: 由类及其后代访问，变量名以单个下划线"\_"开始。
	* public: 均可访问

采用上述规则，再应用到我们的例子中

``` stylus
// employee.h
#ifndef __EMPLOYEE_H__
#define __EMPLOYEE_H__

typedef struct Employee
{
    const char *__szName;
    float __salary;
} Employee;
typedef Employee* PEmployee;

EM_Stat Employee_Con(PEmployee self, const char *szName, float salary);
void Employee_Print(PEmployee self);
EM_Stat Employee_Des(PEmployee self);

#define OOC_Employee_Print(self) Employee_Print(self)
#define OOC_Employee_GetSalary(self) (((PEmployee)(self))->__salary)
#define OOC_Employee_GetName(self) (((PEmployee)(self))->__szName)
#define OOC_Employee_Des(self) Employee_Des(self)
#endif
```
上述类的定义中，使用Employee_Con来构造 Employee 对象，使用Employee_Des来析构它。每个类必须至少有一个构造函数。析构函数是可选的，但即使没有声明析构函数，也可以使用OOC_ClassName_Des函数，使用者必须使用它来清理。这个类的简单实现如下：
``` stylus
// employee.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "util.h"
#include "employee.h"

EM_Stat Employee_Con(PEmployee self, const char *szName, float salary)
{
    self->__szName = malloc(strlen(szName)+1);
    if(self->__szName == NULL)
        return EM_ERR;
    strcpy((char *)self->__szName, szName);
    self->__salary = salary;

    return EM_OK;
}

void Employee_Print(PEmployee self)
{
    printf("Name: %s, Salary: %f", self->__szName, self->__salary);
}

EM_Stat Employee_Des(PEmployee self)
{
    free((void *)self->__szName);
    return EM_OK;
}
```
``` stylus
// main.c

#include <stdio.h>
#include "util.h"
#include "employee.h"

int main()
{
    Employee em;

    if(Employee_Con(&em, "Bob", 10000.0))
    {
        float salary;
        salary = OOC_Employee_GetSalary(&em);
        OOC_Employee_Print(&em);
    }
    OOC_Employee_Des(&em);

    return 0;
}
```
编译运行，输出如下：

``` stylus
Name: Bob, Salary: 10000.000000
```


## 2.2 单继承
类的封装是以一些编程规则和命名约定来实现的，那么类的继承该如何实现呢？在 OOC 框架中，多重继承无法实现，但是我们可以实现单继承和多接口继承，本节我们将详细介绍单继承的实现。

回到刚才的例子，我们实现了一个可以打印员工信息的类，经理作为一个特殊的员工，他具有和普通员工相同的属性，但他有一个额外的属性：级别(level)，如果要打印经理的信息，很显然，我们需要创建一个从 Employee 继承的类，因此借鉴 C++中虚函数的实现，并且重新定义 Print 函数。

``` stylus
// manager.h
#ifndef __MANAGER_H__
#define __MANAGER_H__

typedef struct Manager
{
    Employee super;
    int __level;
} Manager;
typedef Manager* PManager;

EM_Stat Manager_Con(PManager self, const char *szName, float salary, int level);
void Manager_Print(PManager self);

#define OOC_Manager_Print(self) Manager_Print(self)
#define OOC_Manager_GetSalary(self) (((PManager)(self))->super.__salary)
#define OOC_Manager_GetName(self) (((PManager)(self))->super.__szName)
#define OOC_Manager_Des(self) Employee_Des(self)
#endif
```
类的定义如下：

``` stylus
// manager.c

#include <stdio.h>
#include "util.h"
#include "employee.h"
#include "manager.h"


EM_Stat Manager_Con(PManager self, const char *szName, float salary, int level)
{
    if(EM_ERR == Employee_Con(&self->super, szName, salary))
    {
        return EM_ERR;
    }
    self->__level = level;

    return EM_OK;
}

void Manager_Print(PManager self)
{
    Employee_Print(&self->super);
    printf(", Level: %d", self->__level);
}
```

``` stylus
// main.c

#include <stdio.h>
#include "util.h"
#include "employee.h"
#include "manager.h"

int main()
{
    Manager ma;

    if(Manager_Con(&ma, "Bob", 10000.0, 7))
    {
        float salary;
        salary = OOC_Employee_GetSalary(&ma);
        printf("Inheritance test: Salary--%f\n", salary);
        OOC_Manager_Print(&ma);
    }
    OOC_Manager_Des(&ma);

    return 0;
}
```
编译运行，输出为

``` stylus
Inheritance test: Salary--10000.000000
Name: Bob, Salary: 10000.000000, Level: 7
```
上述例子中，可以看出，Manager 这个类它继承了 Employee 的所有属性和方法，并且重新定义了 Print 函数，增加了打印 level 的功能。OOC 中继承实现的关键：**父类的结构体定义必须是子类结构体的第一个成员。**

## 2.3 多态
上个例子的实现中，虽然实现单继承，但是依然存在一个严重的问题：**将子类的指针赋给父类指针的调用有问题**，例如：将 Manager 的指针赋给 Employee 时，如果调用 Print ，调用的是父类的方法，而非子类的方法。

``` stylus
OOC_Employee_Print(&ma);
```
输出为

``` stylus
Name: Bob, Salary: 10000.000000
```
那么多态该如何实现呢？C++的多态是通过虚表来实现的，OOC也是通过类似的方法类实现多态。

首先，我们定义一个全局的父类，即所有的类都必须继承于它，它只包含一个成员：**虚表**。

``` stylus
// ooc.h
#ifndef __OOC_H__
#define __OOC_H__

typedef struct Object * PObject;
typedef struct ObjectClass *PObjectClass;

struct Object
{
    PObjectClass __vptr;
};

struct ObjectClass
{
    EM_Stat (*Des)(PObject);
};

EM_Stat Object_Con(PObject self);
EM_Stat Object_Des(PObject self);

#define OOC_VCALL(OX, CX, MX)\
    (*((P##CX##Class)(((PObject)(OX))->__vptr))->MX)(/*(P##CX)*/(OX))

#endif
```
上述代码中，Object 是全局的父类，而 ObjectClass是 Object 类中虚表的具体定义，它其实就是由一堆函数指针构成。而 Employee 继承于 Object，因此也就继承了 Object 的虚表，它的定义如下：

``` stylus
// employee.h
#ifndef __EMPLOYEE_H__
#define __EMPLOYEE_H__

typedef struct Employee* PEmployee;
typedef struct EmployeeClass * PEmployeeClass;

struct Employee
{
    struct Object super;
    const char *__szName;
    float __salary;
};

struct EmployeeClass
{
    struct ObjectClass super;
    void (*Print)(PEmployee );
    float (*GetSalary)(PEmployee );
};


EM_Stat Employee_Con(PEmployee self, const char *szName, float salary);
void Employee_Print(PEmployee self);
float Employee_GetSalary(PEmployee self);
EM_Stat Employee_Des(PEmployee self);

#define OOC_Employee_Print(self) OOC_VCALL(self, Employee, Print)
#define OOC_Employee_GetSalary(self) OOC_VCALL(self, Employee, GetSalary)
#define OOC_Employee_Des(self) OOC_VCALL(&(self)->super, Object, Des)

#endif
```
EmployeeClass继承于ObjectClass，并扩展了一些自己的方法。类在实例化时，构造函数应该初始化它的虚表。

``` stylus
// employee.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "util.h"
#include "ooc.h"
#include "employee.h"

const struct EmployeeClass __employee={
    {
        Employee_Des
    },
    Employee_Print,
    Employee_GetSalary
};

EM_Stat Employee_Con(PEmployee self, const char *szName, float salary)
{
    EM_Stat err = EM_OK;
    err = Object_Con(&self->super);
    if(EM_ERR == err)
        return err;
    ((PObject)self)->__vptr = (PObjectClass)&__employee;

    self->__szName = malloc(strlen(szName)+1);
    if(self->__szName == NULL)
        return EM_ERR;
    strcpy((char *)self->__szName, szName);
    self->__salary = salary;

    return EM_OK;
}

void Employee_Print(PEmployee self)
{
    printf("Name: %s\n\tSalary: %f\n", self->__szName, self->__salary);
}

float Employee_GetSalary(PEmployee self)
{
    return self->__salary;
}

EM_Stat Employee_Des(PEmployee self)
{
    free((void *)self->__szName);
    return EM_OK;
}

```
类的实现中，我们首先应该实现该类的虚表__employee，并在构造函数中初始化。那么在调用 OOC_CLASS_METHOD 时，通过函数指针，就可以调用虚表中指定的函数。

下面给出 Manager 的定义和实现以及相应的测试代码：

``` stylus
// manager.h
#ifndef __MANAGER_H__
#define __MANAGER_h__

typedef struct Manager* PManager;
typedef struct ManagerClass* PManagerClass;

struct Manager
{
    struct Employee super;
    int __level;
};

struct ManagerClass
{
    struct EmployeeClass super;
    int (*GetLevel)(PManager );
};

EM_Stat Manager_Con(PManager self, const char *szName, float salary, int level);
void Manager_Print(PManager self);
int Manager_GetLevel(PManager self);
EM_Stat Manager_Des(PManager self);

#define OOC_Manager_Print(self) OOC_VCALL(&(self)->super, Employee, Print)
#define OOC_Manager_GetLevel(self) OOC_VCALL(self, Manager, GetLevel)
#define OOC_Manager_GetSalary(self) OOC_VCALL(&(self)->super, Employee, GetSalary)
#define OOC_Manager_Des(self) OOC_VCALL(&(self)->super.super, Object, Des)

#endif
```
``` stylus
// manager.c

#include <stdio.h>
#include "util.h"
#include "ooc.h"
#include "employee.h"
#include "manager.h"

const struct ManagerClass __manager={
    {
        {
            Employee_Des
        },
        Manager_Print,
        Employee_GetSalary
    },
    Manager_GetLevel
};

EM_Stat Manager_Con(PManager self, const char *szName, float salary, int level)
{
    if(EM_ERR == Employee_Con(&self->super, szName, salary))
    {
        return EM_ERR;
    }
    ((PObject)self)->__vptr = (PObjectClass)&__manager;

    self->__level = level;

    return EM_OK;
}

void Manager_Print(PManager self)
{
    Employee_Print(&self->super);
    printf("\tLevel: %d\n", self->__level);
}

int Manager_GetLevel(PManager self)
{
    return self->__level;
}

```

``` stylus
// main.c

#include <stdio.h>
#include "util.h"
#include "ooc.h"
#include "employee.h"
#include "manager.h"

int main()
{
    EM_Stat err;
    struct Employee em;
    struct Manager ma;
    PEmployee pEm[2];

    err = Employee_Con(&em, "Jim", 5000.0);
    err = Manager_Con(&ma, "Bob", 10000.0, 7);

    pEm[0] = &em;
    pEm[1] = &ma;
    {
        int i;
        for(i = 0; i < 2; i++)
            OOC_Employee_Print(pEm[i]);
    }
    OOC_Manager_Des(&ma);
    OOC_Employee_Des(&em);

    return 0;
}

```
编译运行，得到如下结果：

``` stylus
Name: Jim
	Salary: 5000.000000
Name: Bob
	Salary: 10000.000000
	Level: 7
```
可以看到，我们使用父类的指针，实现了子类方法的调用。


## 2.4 多接口继承

# 3 总结
